# 错误处理

为了能够自定义错误提供更多错误的上下文信息，同时能够与依赖中的错误相兼容，我选择使用两个类型 `KvsError` 和 `KvsErrorType`，并利用 failure 库中的 `Context` 在两者之间进行转换。

# 数据持久化

将每次操作（ get 操作因为不涉及数据变化而除外）以日志的方式持久化到文件上，所有的数据保存于一个文件上。

## 数据表示

在内存中用 `enum Operation` 表示操作，写入文件时将其通过 serde 序列化成 JSON 格式的字符串。读取时顺序读取，每一个完整 JSON 对象即为一个操作，通过 serde 反序列化后转换成内存中的枚举对象 `Operation`。

## index 表示

值数据在内存中转换成了通过日志指针的方式存储，即通过记录在文件中的位置来读取数据，而非直接存储值数据本身。

因为 index 的数据类型从 `HashMap<String, String>` 变成了 `HashMap<String, Offset>`，其中 `Offset` 为一个结构体看，记录了数据在文件中的偏移量和长度，在系统初始化过程中读取数据文件时构建。

## 数据压缩

文件中的数据根据 key 分类，如果最后一次操作为 set 则只保留最后一个操作，如果最后一次操作为 remove 则全部删除。在日常操作过程中跟踪可压缩的数据大小（`KvStore.could_be_compacted`），当其超过阈值 `COMPACT_THERASHOLD` 时触发压缩操作。

压缩时会创建一个新文件，然后将当前 index map 中的数据全部写入到新文件中，然后将所有文件指针（`BufWriter`、`BufReader` 等）更新至新文件上，最后删除旧文件。

这里还涉及了一个识别哪个是最新的数据文件问题。我选择使用一个文件 id （`KvStore.cur_file_id`）的方式记录版本，该 id 只会不断递增，每次压缩时加一，同样持久化到硬盘中。初始化时也会读取该文件以获取最新的文件 id。
