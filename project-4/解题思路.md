# 线程池

创建线程时，让每个线程执行一个无限循环的函数 `worker_thread`，各个线程与主线程间通过一对 `Sender` 和 `Receiver` 通信。`worker_thread` 的工作内容就是不断请求 `Recevier` 的锁，获得之后取出其中一条消息并处理，否则等待。

消息内容分为两种 `NewJob` 和 `Terminate`，前者则执行新任务，后者结束循环，线程终止。当线程池被销毁时，会在析构函数中向 `Sender` 中追加线程数量个 `Terminate` 消息以让所有线程在任务全部处理完毕后终止。

当线程中遇到 panic 时，该线程会销毁，同时会重新建立一个新的线程。这一部分主要由 `Worker` 的 `Drop` trait 实现，当线程 panic 函数结束调用析构函数，此时会检查线程是否 panic，如果是就会建立一个新线程继续执行任务。

# 无锁读

数据库读写主要的数据为 `KvStore.map`，原本为 `HashMap`，为了能够让其并发安全，换用了 `crossbeam::SkipMap`。使用过程中用 `Arc` 指针存储，保证全局只存有一份，且可以方便复制到各个线程之中。

在使用过程中将读写操作分离，将所有写相关的数据转移至了 `KvStoreWriter` 中，并将该结构用 `Mutex` 保护，实现了互斥写。在 `KvStore` 中也存有一个 `KvStore.map` 的 `Arc` 指针仅用于读操作。

压缩发生于 set 和 remove 的操作过程中，因此只有拥有锁时会发生压缩，而且数据在此过程中不会发生变化。压缩过程中同时更新内存中的索引，因为压缩时旧文件并未被删除，因此无论读到的是老文件还是新文件都是最新的数据。压缩完成后释放锁，此时索引中都指向了新文件，之后便可以继续正常工作。